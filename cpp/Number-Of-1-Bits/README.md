# 题目描述: 位1的个数

编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。

**示例 1:**
```
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
```

**示例 2:**
```
输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
```
  
# 解题思路:
此题与剑指offer第15题类似

根据 与运算 定义，设二进制数字 n ，则有：
    - 若 n&1=0 ，则 n 二进制 最右一位 为 0
    - 若 n&1=1 ，则 n 二进制 最右一位 为 1

如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。

举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。

  如图所示：
  ![](https://pic.leetcode-cn.com/abfd6109e7482d70d20cb8fc1d632f90eacf1b5e89dfecb2e523da1bcb562f66-image.png)
  
 
# 时间复杂度：
  时间复杂度：O(M)
  n&(n−1) 操作仅有减法和与运算，占用 O(1)O(1)O(1) ；设 M为二进制数字 n 中 1 的个数，则需循环 M次（每轮消去一个 1 ），占用 O(M)
# 空间复杂度
  O(1)
# 代码

## [C++](./Number-Of-1-Bits.cpp):
```c++
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int res = 0;
        while(n!=0)
        {
            res++;
            n = (n-1)&n;
        }
        return res;
    }
};
```

## [Python:](https://github.com/bryceustc/LeetCode_Note/blob/master/python/Number-Of-1-Bits/Number-Of-1-Bits.py)
###  
```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        res = 0
        while n:
            res +=1
            n&=n-1
        return res
```
# 参考
  - [剑指offer第15题-Number-Of-1-Bits](https://github.com/bryceustc/CodingInterviews/blob/master/NumberOf1InBinary/README.md)
